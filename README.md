# Concurrent-computing

Разработаем программу, симулирующую конкурентную работу. Данная программа доступна на GOLANG. Ищите репозиторий - https://github.com/DEPTH-STRIDA/Concurrent-computing

## Введение

В компьютерном программировании конкурентность — способность компьютера справляться с множеством разных задач одновременно. Давайте возьмем для примера использование браузера. Если мы гуляем по сети, происходит много вещей одновременно. Например, идет скачивание файла в то время как мы слушаем музыку и скролим веб-сайт в другой вкладке. Можно сказать, что компьютер выполняет несколько задач одновременно. Если бы компьютеры так не умели, нам бы пришлось ждать окончание скачивания файла, чтобы продолжить слушать музыку или скролить сайт.

Архитектура ЦПУ устроена таким образом, что одно ядро может выполнять лишь одно действие в единицу времени. В наши дни на рынке все еще есть множество одноядерных процессоров. Но если у вас компьютер с одноядерным процессором, то неужели мы не сможем скачивать файл, слушать музыку и листать новостную ленту в другой вкладке одновременно? Конечно, сможем, а достигается это с помощью конкурентности. Давайте посмотрим диаграмму, которая демонстрирует как одноядерный ЦПУ справляется с примером с браузером.

![image](https://github.com/DEPTH-STRIDA/Concurrent-computing/assets/92984389/08efeef9-7008-4ee6-8d79-048b788bdfc6)

Как мы можем увидеть, все задачи разбиваются на кусочки, которые делятся по приоритетности, а ЦПУ постоянно переключается между ними, создавая иллюзию одновременного исполнения.

## Описание программы

Создадим программу на языке программирования Go, которая будет получать уже разбитые задачи и выполнять их. Программу реализуем с помощью событийно-ориентированной модели программирования. В центральном классе будет находиться основной цикл, который выбирает и обрабатывает событие, при этом создаются события в цикле.

### Главный цикл

Главный цикл обрабатывает список событий, в который динамически добавляются новые события.

### Типы событий

У нас будет 3 типа событий:
1. **Запрос новой задачи и предоставление доступа к процессору:** с самого начала у нас одно событие этого типа. При обработке происходит добавление задачи (увеличение L), добавление следующего события 1-го типа (с удалением обработанного), а если процессор свободен, то добавляется событие второго типа (обработка только что добавленной задачи). Время, которое идет вместе с кодом события, указывает в какой момент времени оно случилось, т.е. выполняется моментально.
2. **Завершение обработки задачи:** данное событие символизирует конец обработки задачи и проверяет, остались ли еще задачи. Если (L>0) есть еще необработанные задачи, то добавляется следующее событие второго типа. Время, которое идет вместе с кодом события, указывает в какой момент времени закончилась работа задачи.
3. **Завершение работы программы:** это событие происходит при выполнении заранее запланированной задачи или при переполнении максимального возможного количества задач.

Мы реализуем эту программу, чтобы продемонстрировать, как можно управлять и симулировать конкурентность на одноядерном процессоре.
